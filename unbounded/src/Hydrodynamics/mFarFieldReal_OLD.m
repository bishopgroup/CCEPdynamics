function [localVelocity, localVelocityGradient] = ...
    mFarFieldReal(Parameter, Particle)
%--------------------------------------------------------------------------
% pFarFieldReal - computes "local" contribution to velocity and velocity 
%                 gradient due to particle forces and dipoles.
%
% [localPotential,localPotentialGradient] = ...
%                                     pFarFieldReal(Parameter, Particle)
%--------------------------------------------------------------------------

I = eye(3);

% Allocate output variables
Np = Particle.nParticle;
localVelocity = zeros(Np, 3); 
localVelocityLaplacian = zeros(Np, 3);  
localVelocityGradient = zeros(Np, 3, 3);  
localVelocityLaplacianGradient = zeros(Np, 3, 3);


%% interparticle distance matrix

% compute components of the separation vector
deltaX = bsxfun(@minus, Particle.position(:,1), ...
    Particle.position(:,1)');
deltaY = bsxfun(@minus, Particle.position(:,2), ...
    Particle.position(:,2)');
deltaZ = bsxfun(@minus, Particle.position(:,3), ...
    Particle.position(:,3)');

% account for periodic boundaries
deltaX = deltaX - round(deltaX / Parameter.domainLength) ...
    * Parameter.domainLength;
deltaY = deltaY - round(deltaY / Parameter.domainLength) ...
    * Parameter.domainLength;
deltaZ = deltaZ - round(deltaZ / Parameter.domainLength) ...
    * Parameter.domainLength;

% Compute interparticle distance matrix (Brute Force)
r = sqrt(deltaX.^2 + deltaY.^2 + deltaZ.^2);
r(logical(eye(size(r)))) = Inf;

% Compute unit displacement vectors
e = zeros(Np,Np,3);
e(:,:,1) = deltaX ./ r;
e(:,:,2) = deltaY ./ r;
e(:,:,3) = deltaZ ./ r;

%% Compute Green's functions and its derivatives
Greens = GreensFunction(r, Parameter); 


%% Compute velocity due to forces, dipoles, quadrupoles, octupoles

% due to forces, Gij*fj 
%   Gij = G1*dij - G2*(dij - ei*ej)
for i = 1:3
    for j = 1:3
        localVelocity(:,i) = localVelocity(:,i) ...
            + (Greens.G1 * I(i,j)) * Particle.force(:,j) ...
            - (Greens.G2 .* (I(i,j) - e(:,:,i) .* e(:,:,j))) * Particle.force(:,1);
    end
end

% due to dipoles, DnGij * Dnj 
%   DnGij = (dG1 - dG2)*en*dij + dG2*en*ei*ej + *ei*ej) )
for i = 1:3
    for n = 1:3
        for j = 1:3
            localVelocity(:,i) = localVelocity(:,i) ...
                + ((Greens.dG1 - Greens.dG2) .* e(:,:,n) * I(i,j)) * Particle.force(:,j) ...
                + (Greens.G2 .* (I(i,j) - e(:,:,i) .* e(:,:,j))) * Particle.force(:,1);
        end
    end
end

% localVelocity(:,2) =  Greens.G1 * Particle.force(:,2) ...
%     + (Greens.G2 .* (-e2 .* e1)) * Particle.force(:,1)  ...
%     + (Greens.G2 .* (1 - e2 .* e2)) * Particle.force(:,2) ...
%     + (Greens.G2 .* (-e2 .* e3)) * Particle.force(:,3);
% localVelocity(:,2) =  Greens.G1 * Particle.force(:,2) ...
%     + (Greens.G2 .* (-e2 .* e1)) * Particle.force(:,1)  ...
%     + (Greens.G2 .* (1 - e2 .* e2)) * Particle.force(:,2) ...
%     + (Greens.G2 .* (-e2 .* e3)) * Particle.force(:,3);
% 
% localVelocity(:,3) =  Greens.G1 * Particle.force(:,3) ...
%     + (Greens.G2 .* (-e3 .* e1)) * Particle.force(:,1)  ...
%     + (Greens.G2 .* (-e3 .* e2)) * Particle.force(:,2) ...
%     + (Greens.G2 .* (1 - e3 .* e3)) * Particle.force(:,3);
% 
% % due to dipoles ( DnGij * Dnj with Gij = G1*dij + G2*(dij - ei*ej) )
% localVelocity(:,1) = localVelocity(:,1) + ...
% Greens.G1 * Particle.force(:,1) ...
%     + (Greens.G2 .* (1 - e1 .* e1)) * Particle.force(:,1)  ...
%     + (Greens.G2 .* (-e1 .* e2)) * Particle.force(:,2) ...
%     + (Greens.G2 .* (-e1 .* e3)) * Particle.force(:,3);
% localVelocity(:,2) =  Greens.G1 * Particle.force(:,2) ...
%     + (Greens.G2 .* (-e2 .* e1)) * Particle.force(:,1)  ...
%     + (Greens.G2 .* (1 - e2 .* e2)) * Particle.force(:,2) ...
%     + (Greens.G2 .* (-e2 .* e3)) * Particle.force(:,3);
% localVelocity(:,3) =  Greens.G1 * Particle.force(:,3) ...
%     + (Greens.G2 .* (-e3 .* e1)) * Particle.force(:,1)  ...
%     + (Greens.G2 .* (-e3 .* e2)) * Particle.force(:,2) ...
%     + (Greens.G2 .* (1 - e3 .* e3)) * Particle.force(:,3);

% due to dipoles
% localVelocity = localVelocity ...
%     - (dG .* e1) * Particle.farFieldDipole(1,:)' ...
%     - (dG .* e2) * Particle.farFieldDipole(2,:)' ...
%     - (dG .* e3) * Particle.farFieldDipole(3,:)';


%%  Compute potential gradient due to charges and dipoles

% due to charges
% localPotentialGradient(1,:) = (e1 .* dG) * Particle.farFieldCharge;
% localPotentialGradient(2,:) = (e2 .* dG) * Particle.farFieldCharge;
% localPotentialGradient(3,:) = (e3 .* dG) * Particle.farFieldCharge;
%     
% % due to dipoles
% localPotentialGradient(1,:) = localPotentialGradient(1,:)' ...
%     + ((-d2G + dGor) .* e1 .* e1) * Particle.farFieldDipole(1,:)' ...
%     + ((-d2G + dGor) .* e1 .* e2) * Particle.farFieldDipole(2,:)' ...
%     + ((-d2G + dGor) .* e1 .* e3) * Particle.farFieldDipole(3,:)' ...
%     - dGor * Particle.farFieldDipole(1,:)';
% localPotentialGradient(2,:) = localPotentialGradient(2,:)' ...
%     + ((-d2G + dGor) .* e2 .* e1) * Particle.farFieldDipole(1,:)' ...
%     + ((-d2G + dGor) .* e2 .* e2) * Particle.farFieldDipole(2,:)' ...
%     + ((-d2G + dGor) .* e2 .* e3) * Particle.farFieldDipole(3,:)' ...
%     - dGor * Particle.farFieldDipole(2,:)';
% localPotentialGradient(3,:) = localPotentialGradient(3,:)' ...
%     + ((-d2G + dGor) .* e3 .* e1) * Particle.farFieldDipole(1,:)' ...
%     + ((-d2G + dGor) .* e3 .* e2) * Particle.farFieldDipole(2,:)' ...
%     + ((-d2G + dGor) .* e3 .* e3) * Particle.farFieldDipole(3,:)' ...
%     - dGor * Particle.farFieldDipole(3,:)';


%--------------------------------------------------------------------------
function Greens = GreensFunction(r,Parameter)
% computes the 'local' Green's function and its derivatives
rhoSquared = pi * r.^2 / Parameter.splittingAlpha;
rho = sqrt(rhoSquared);

% G1(rho) and derivatives
Greens.G1 = (1.5 / Parameter.splittingAlpha^0.5) ...
    * expIntegralE(0.5, rhoSquared);

Greens.dG1 = (-3 * sqrt(pi) / Parameter.splittingAlpha) ...
    * rho .* expIntegralE(-0.5, rhoSquared);

Greens.d2G1 = (3 * pi / Parameter.splittingAlpha^1.5) ...
    * (2 * rhoSquared .* expIntegralE(-1.5, rhoSquared) ...
    - expIntegralE(-0.5, rhoSquared));

Greens.d3G1 = (6 * pi^1.5 / Parameter.splittingAlpha^2) * rho ...
    .* (-2 * rhoSquared .* expIntegralE(-2.5, rhoSquared) ...
    +  3 * expIntegralE(-1.5, rhoSquared));

% G2(rho) and derivatives
Greens.G2 = (1.5 / Parameter.splittingAlpha^0.5) ...
    * rhoSquared .* expIntegralE(-0.5, rhoSquared);

Greens.dG2 = (-3 * sqrt(pi) / Parameter.splittingAlpha) * rho ...
    .* (rhoSquared .* expIntegralE(-1.5, rhoSquared) ...
    - expIntegralE(-0.5, rhoSquared));

Greens.d2G2 = (3 * pi / Parameter.splittingAlpha^1.5) ...
    * (2 * rhoSquared.^2 .* expIntegralE(-2.5, rhoSquared) ...
    - 5 * rhoSquared .* expIntegralE(-1.5, rhoSquared) ...
    + expIntegralE(-0.5, rhoSquared));

Greens.d2G3 = (-6 * pi^1.5 / Parameter.splittingAlpha^2) * rho...
    .* (2 * rhoSquared.^2 .*expIntegralE(-3.5, rhoSquared)...
    - 9 * rhoSquared .* expIntegralE(-2.5, rhoSquared) ...
    + 6 * rhoSquared .* expIntegralE(-1.5, rhoSquared));

% Make diagonal elements zero
diagonal = logical(eye(size(r)));
Greens.G1(diagonal) = 0;
Greens.dG1(diagonal) = 0;
Greens.d2G1(diagonal) = 0;
Greens.d3G1(diagonal) = 0;
Greens.G2(diagonal) = 0;
Greens.dG2(diagonal) = 0;
Greens.d2G2(diagonal) = 0;
Greens.d3G2(diagonal) = 0;


%--------------------------------------------------------------------------
function E = expIntegralE(n,z)
% this function reproduces the Mathematica function ExpIntegralE[n,z]

E = gamma(1-n) * gammainc(z,1-n,'upper') .* z.^(n-1);


